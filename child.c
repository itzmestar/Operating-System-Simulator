//  child.c: the child program
#include "global.h"
//#include <string.h>

//global variable section
	int *ShmCLOCKPTR=NULL;
	int ShmCLOCKID;
	int *shm_msgPTR=NULL;                        
    int shm_msgID;
	int clock_sem_set_id;            /* ID of the semaphore set */
	
	int p_seconds=0; 		//parent clock seconds
	int p_nanoseconds=0;	//parent clock nano seconds
	int term_sec=0;			//terminate time sec value
	int term_nsec=0;		//terminate time nano sec value

//returns 0 if terminate itself after critical section
int critical_section(){
	int sec=0, nsec=0;
	
	read_clock(ShmCLOCKPTR, &p_seconds, &p_nanoseconds);
	if (is_time_up()==1)
		return 1;
	
	//time is up
	
	//read shm_msg
	read_shm_msg(shm_msgPTR, &sec, &nsec);
	
	//if shm_msg not empty then return
	if ( sec !=0 || nsec != 0 )
		return 1;
	
	//update shm_msg
	update_shm_msg(shm_msgPTR, p_seconds, p_nanoseconds);
	return 0;
}

// returns 1 -> not up
// 0 -> up
int is_time_up(){
	if (p_seconds < term_sec){
		return 1;
	}else if (p_seconds > term_sec){
		return 0;
	}else {
		if (p_nanoseconds >= term_nsec){
			return 0;
		}
	}
	return 1;
}

//clean up
void cleanup(){
	//Detach & Free shared memory
	if(ShmCLOCKPTR!=NULL)
		detach_shared_memory(ShmCLOCKPTR);
	if(shm_msgPTR!=NULL)
		detach_shared_memory(shm_msgPTR);
}

//handle signal
void sig_handler(int signo)
{
  if (signo == SIGQUIT){
    //printf("received SIGINT\n");
	cleanup();
	exit (1);
  }
}

int main (int argc, char **argv)
{
    //Shared Memory Clock related            
	key_t clock_key;                         
	
	//Shared Memory shm_msg related            
	key_t shm_msg_key;                         

	//semaphore related
	int sem_set_id;            // ID of the semaphore set 

 //   int i, j;
//    long sum;

	//handle signal
	if (signal(SIGQUIT, sig_handler) == SIG_ERR)
		printf("\ncan't catch SIGINT\n");
	
	//generate key to be used in semaphore & shared mem for clock
	clock_key = generate_key(MAINPRGM, CLOCKID);
	
	/* find the a shared memory segment created by parent*/
	ShmCLOCKID = get_shared_memory(clock_key, CLOCKSIZE ,0400);
	
	/* attach the shared memory segment to process's address space. */
	ShmCLOCKPTR = get_shared_memory_addr(ShmCLOCKID );
 
	//generate key to be used in Shared Memory shm_msg
	shm_msg_key = generate_key(MAINPRGM, SHMMSGID);
	
	/* find the a shared memory segment created by parent*/
	shm_msgID = get_shared_memory(shm_msg_key, CLOCKSIZE, 0600 );
	
	/* attach the shared memory segment to process's address space. */
	shm_msgPTR = get_shared_memory_addr(shm_msgID);
	
	
	//reading the simulated time system clock generated by oss.
	read_clock(ShmCLOCKPTR, &p_seconds, &p_nanoseconds);
	
	//get the semaphore
	sem_set_id = get_semaphore(clock_key, 1, 0644);
	
	//generate a random duration number from 1 to 1,000,000 & save in terminating time.
	term_sec=p_seconds;
	term_nsec=p_nanoseconds + random_num(1,1000000);
	
	//loop till times up
	 while(1){
 		sem_lock(sem_set_id);
		
		if (critical_section()==0){
			sem_unlock(sem_set_id);
			break;
		}
		sem_unlock(sem_set_id);
    }
	
	cleanup();
    return 0;
}
